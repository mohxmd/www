<div
  class="pointer-events-none fixed top-0 right-0 bottom-0 left-0 print:hidden"
  style="z-index: -1"
  id="tree-container"
>
  <canvas id="tree-canvas" width="400" height="400"></canvas>
</div>

<script>
  const r180 = Math.PI;
  const r90 = Math.PI / 2;
  const r15 = Math.PI / 12;
  const color = "#88888825";
  const { random } = Math;
  const MIN_BRANCH = 30;

  let canvas: HTMLCanvasElement;
  let ctx: CanvasRenderingContext2D;
  let size = { width: 0, height: 0 };
  let len = 6;
  let steps: (() => void)[] = [];
  let prevSteps: (() => void)[] = [];
  let controls: { pause: () => void; resume: () => void };

  function getWindowSize() {
    return {
      width: window.innerWidth,
      height: window.innerHeight,
    };
  }

  function initCanvas(canvas: HTMLCanvasElement, width = 400, height = 400) {
    const ctx = canvas.getContext("2d")!;
    const dpr = window.devicePixelRatio || 1;

    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    canvas.width = dpr * width;
    canvas.height = dpr * height;
    ctx.scale(dpr, dpr);

    return { ctx, dpr };
  }

  function polar2cart(x = 0, y = 0, r = 0, theta = 0): [number, number] {
    const dx = r * Math.cos(theta);
    const dy = r * Math.sin(theta);
    return [x + dx, y + dy];
  }

  const step = (x: number, y: number, rad: number, counter: { value: number } = { value: 0 }) => {
    const length = random() * len;
    counter.value += 1;
    const [nx, ny] = polar2cart(x, y, length, rad);
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(nx, ny);
    ctx.stroke();
    const rad1 = rad + random() * r15;
    const rad2 = rad - random() * r15;

    if (nx < -100 || nx > size.width + 100 || ny < -100 || ny > size.height + 100) return;

    const rate = counter.value <= MIN_BRANCH ? 0.8 : 0.5;
    if (random() < rate) steps.push(() => step(nx, ny, rad1, counter));
    if (random() < rate) steps.push(() => step(nx, ny, rad2, counter));
  };

  let lastTime = performance.now();
  const interval = 1000 / 40;
  let animationId: number;

  const frame = () => {
    if (performance.now() - lastTime < interval) {
      animationId = requestAnimationFrame(frame);
      return;
    }
    prevSteps = steps;
    steps = [];
    lastTime = performance.now();
    if (!prevSteps.length) {
      controls.pause();
      return;
    }
    prevSteps.forEach((i) => {
      if (random() < 0.5) steps.push(i);
      else i();
    });
    animationId = requestAnimationFrame(frame);
  };

  controls = {
    pause: () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    },
    resume: () => {
      animationId = requestAnimationFrame(frame);
    },
  };

  const randomMiddle = () => random() * 0.6 + 0.2;

  const start = () => {
    controls.pause();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 1;
    ctx.strokeStyle = color;
    prevSteps = [];
    steps = [
      () => step(randomMiddle() * size.width, -5, r90),
      () => step(randomMiddle() * size.width, size.height + 5, -r90),
      () => step(-5, randomMiddle() * size.height, 0),
      () => step(size.width + 5, randomMiddle() * size.height, r180),
    ];
    if (size.width < 500) steps = steps.slice(0, 2);
    controls.resume();
  };

  const updateMask = () => {
    const container = document.getElementById("tree-container");
    if (container) {
      const mask = "radial-gradient(circle, transparent, black)";
      container.style.maskImage = mask;
      container.style.webkitMaskImage = mask;
    }
  };

  const handleResize = () => {
    size = getWindowSize();
    const { ctx: newCtx } = initCanvas(canvas, size.width, size.height);
    ctx = newCtx;
    start();
    updateMask();
  };

  document.addEventListener("DOMContentLoaded", () => {
    canvas = document.getElementById("tree-canvas") as HTMLCanvasElement;
    if (!canvas) return;

    size = getWindowSize();
    const result = initCanvas(canvas, size.width, size.height);
    ctx = result.ctx;

    updateMask();
    start();

    window.addEventListener("resize", handleResize);
  });
</script>

<style>
  #tree-container {
    mask-image: radial-gradient(circle, transparent, black);
    -webkit-mask-image: radial-gradient(circle, transparent, black);
  }
</style>
